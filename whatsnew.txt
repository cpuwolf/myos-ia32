2004-7-3 	
取消了bottom half结构。跟linux学不一定是有效的！

2004-8-2  	
增加分区表的读取
开始修改fat文件系统，开始支持fat16 fat32

20:08 2004-8-4
今天好像有很多技术内容要说。总结一下：
我遇到一个问题。现在我的用户进程只能将它调用system_call处，而内核中的system_call只能一口气执行完,不可block。这样我为读底层磁盘设的system_call使我不能再为文件系统在设system_call，文件系统只能在用户层。我思考了很久。
当我看《linux设备驱动》时，里面提到概念----可重入代码，引起我的重视。我想linux是把system_call函数看成进程运行的一部分，虽然代码在内核，也有状态，应该保存在进程表中。现在看进程表有两种状态信息：1。用户进程本身的状态。2。调用system_call时内核的状态。不知道我的猜测对否？今晚看一下代码核实一下

21:57 2004-8-6
上次我的猜测得到验证是正确的。敲门在schedule的switch_to()，但是对内核线程上下文的保存我还是?????:(
实现对内存的管理(1M以前保留)，内核栈就放在1M以前，任务栈动态分配成功！
改变了生成的内核布局，将.bss段放在最后，.rodata和.data合并。这样是为了减小内核的大小，因为.bss是不初始化的，可以忽略。


22:14 2004-8-9
到今天，我才成功将所有的进程用的临时gdt转为使用自己的ldt.我中间出了点问题，PCB切换时，指向LDT_selector的进程的内核堆栈位置算错了，让我想了两天，小问题不可忽视呀！！！:)
内核section多了个段.text.init存放内核初始化代码

21:36 2004-8-11
我决定作一次大的改动，为每个进程加上一个内核线程

21:43 2004-8-14
有些宏GET_CURRENT为了与linux保持一致，对sys.S进行了修改	

22:56 2004-8-26
我还没做好改动的准备，待我将fat文件系统改好后再来大改，它不会影响我的大改动	

16:29 2004-8-30
今天对内核的内存布局进行了调整，多了个段.text.isr 将中断服务历程集中在一起，并将内核堆栈的位置保持与linux一致。

15:04 2004-9-3
今天提出了进程控制块的改制方案，分两步完成，老版内核将进程上下文放在struct proc的头部，第一步：将进程上下文所占的空间扩大，并将为内核专设的内核堆栈取消，把他们移到这里。第二步：将进程上下文移到进程控制块的尾部，让内核堆栈向进程控制块的参数部分扩展。

19:03 2004-9-3
成功！改制了进程切换引擎！高兴的无话可说！2004-8-4到现在，终于转换过来了

22:37 2004-9-6
在不降低效率的基础上，我把中断入口的代码缩减，编译后内核减小了大概500字节，备份在os_irq_new.rar中

16:13 2004-9-14
将Makefile做了改进，现在它更加结构化。

16:13 2004-9-16
将*.h的结构做了改进，使其可以互相包含。

16:10 2004-9-17
今天完成了对内核空间的动态分配函数kmalloc(),kfree()，采用UNIX BSD4.4分配思想，将内存划分成页，页的大小初步定为1024字节，共20页。

13:49 2005-3-26
花了两天将内核改制成bootloader与内核的模式。内核中实模式的setup读到0x90000，保护模式部分载入到0x10000

17:06 2005-3-30
将init进程要用到的库函数题了出来，放在lib/下
**Bug报告:文件系统中，为进程选1个空闲文件描述符用到的get_zero_bit函数实错误的。